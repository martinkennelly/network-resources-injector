package service

import (
	"os"
	"reflect"

	"github.com/golang/glog"
)

type Service interface {
	Run() error
	Quit() error
	StatusSignal() chan struct{}
	GetName() string
}

// Watch blocks until signal generated by os signal or service(s). Usage of reflect to allow scaling the number of select
// cases to match the number of services available instead of hard coding the number of cases/services.
func Watch(term chan os.Signal, services ...Service) (err error) {
	totalSvc := len(services)
	cases := make([]reflect.SelectCase, totalSvc+1) // plus one to add term channel
	for i, svc := range services {
		cases[i] = reflect.SelectCase{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(svc.StatusSignal())}
	}
	cases[totalSvc] = reflect.SelectCase{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(term)}
	chosen, _, ok := reflect.Select(cases) // blocks until signal received by case(s)
    // when a channel is closed, 'ok' will be false. If a value is received, which is typical op for os.signal chan,
    // then 'ok' will be true.
	if ok {
		if chosen >= totalSvc {
			glog.Infof("termination signal received. Terminating all services")
		} else {
			glog.Infof("signal from service '%s' received. Terminating all services", services[chosen].GetName())
		}
	} else {
		glog.Warningf("service or OS signal channel was closed unexpectedly. Terminating all services")
	}
	return closeServices(services)
}

func closeServices(services []Service) (err error) {
	for _, svc := range services {
		if err := svc.Quit(); err != nil {
			return err
		}
		glog.Infof("service '%s' ended successfully", svc.GetName())
	}
	return nil
}
